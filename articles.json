{
  "articles": [
    {
      "title": "From Newbie to Expert in 6 months",
      "author": "Ahmadsm2005",
      "content": "Hello there. I would like to share my experience on how I reached Expert in my first 6 months. A few people asked me about that so I am writing a blog for everyone to see and the techniques I used to reach expert in 6 months. I started Competitive Programming 8 months ago. I didn't know except some basics about visual basic programming language and I didn't know except to do some GUI and write basic code. I was introduced to CP and how important it was from university admissions to job interviews. I began to learn step by step new ideas, new algorithms etc... From my experience, I would like to share those important tips from my point of view:\n\nAlways train CP with a target. This really helps you to train and read articles(like implementation and algorithms and maths) to reach your target as fast as possible\n\nTrain with your friends. Training with your friends and trying to out perform them.\n\nAlways take rating seriously and compete online in many sites. Rating sometimes doesn't mean your real performance. Your real performance sometimes might be worse or better than your rating but it won't be further than +100/-100. If rating was to be taken seriously, you would try your best to solve the problem within the contest and prevent rating loss.\n\nAlways expect a reward. Even if the reward would take a long time or it would be small, expecting a reward is a really good boost for you to train.\n\nLearn new algorithms and data structures. Learning them is very important(for example DFS,segment trees,Dijkstra,etc...). Mathematics is also very important(especially forming equations,number theories,combinatorics,etc...)\n\nDon't solve too easy problems. Solving too easy problems won't make you get better. Also, you should solve on the topics you are weak on and solve randomly(random solving problems a little bit higher than your rating is one of the best practicing techniques!)\n\nAlways try to solve problems you don't get during a real contest. That would teach you new techniques and ideas you missed to think about during the contest!\n\nYou should like competitive programming. Most of the time if you like a subject, you would be good at it!\n\nCheck the editorial if you failed. Failing is part of the training. Even if you find that you fail a lot, failure will turn to success after you learn the new ideas/techniques/ways of thinking. Most importantly, you should check the editoral if you failed to solve the current problem.",
      "tags": ["codeforces", "newbie", "expert"]
    },
    {
      "title": "Pro Tips — get them while they are free",
      "author": "Um_nik",
      "content": "Stop caring about the rating: Unless there are prizes involved, your position in the standings makes no difference. I can feel awful after winning a contest if I know that I could solve one more problem. Or I can feel OK losing a bunch of rating points knowing that I solved everything I could.  Because rating is just a number. It is highly volatile and it depends on other people, not only on your skill. But solving problems is totally up to you. And you should evaluate yourself not based on some random metric, but on your honest feeling whether you performed up to your expectations. Your sense of self should be under your control, don't get hung up on some imaginary value, you cannot reduce your progress to a single number.\n\nDon't use more than one account: Rating is just a number. Do not be afraid to lose your colour. You’ll get it back in no time if you continue to improve.You don’t need a second account for shitposting either. If you think something you are doing is shit and you don't want it associated with your main account you shouldn't do it at all. Either be proud of your trolling (and do it from your main account) or don't do it.\n\nWrite contests (duh): You may think that you are not ready to write some contests, that you need more practice solving problems without time restrictions. And yeah, practice is a necessary part of progress, but you will never learn how to function under pressure without writing contests. The best way to learn how to do X is to try to do X.\n\nDelete rating predictor: What is even the point of it? Does it help you make a decision of what to do? What problem to solve? What problem to hack? No. It may give you motivation, but it may also break your motivation by giving you a false sense of security.\n\nAnd besides, rating is just a number. Your sole goal during the contest should be to solve as much as you can. As fast as you can, as optimal as you can, and hacking on the side comes later. Focus on solving. Focus on the next problem. That is it. Round is just a series of intervals where you focus on the new problem.\n\nRating is way too random to be tied to your sense of achievement. Be proud of yourself for solving problems, not for your place and rating change.\n\nUpsolve to your next level: Let's say you want to be able to solve ABC div2 during the round. Well, the best way to do that is to always solve ABC, but not necessarily during the round. Upsolve! You can do it on your own or with an editorial. If there is a hard implementation point that you cannot figure out, try to understand someone else's code for that problem.\n\nIt’s not a replacement for solving archives, it’s addition. Archives have a lot of problems (duh) and most of them are old (duuh). That can create an incentive for you to skip “random half” of problems, which is not actually random, but the problems you subconsciously didn’t like. By upsolving you are making sure that you are covering topics that appear in the current meta.\n\nThe best way to learn how to do X is to try to do X.",
      "tags": ["codeforces", "cp", "ratings"]
    },
    {
      "title": "What if you excel in programming but struggle with data structures and algorithms during interviews?",
      "author": "sam2301",
      "content": "Data structures and algorithms play a crucial role in any development position, but perhaps not in the conventional sense often portrayed. It's not solely about mastering abstract concepts like trees or linked lists, or memorizing various sorting methods. Rather, the focus should be on their application within specific domains.\n\nThe heart of most software lies in managing and manipulating data, whether it's financial records, sensor readings, molecular structures, transit schedules, or game states. The choice of data structures and algorithms is heavily influenced by the particular domain and application at hand. For instance, handling high-volume sensor data requires a different approach than managing bank accounts or simulating protein folding.\n\nDuring interviews, it's essential to demonstrate an understanding of data structures and algorithms tailored to the company's field, markets, products, and software architecture preferences. This approach ensures relevance and practicality in solving real-world problems. In my experience, both as an interviewer and interviewee, this contextual understanding is key.",
      "tags": ["dsa", "interviews", "software engineering"]
    },
    {
      "title": "Why do interviewers care so much about algorithm and data structures?",
      "author": "aditsahu25",
      "content": "Interviewers often prioritize assessing candidates' knowledge of algorithms and data structures during technical interviews for several reasons:\n\nProblem-solving skills: Demonstrating proficiency in algorithms and data structures showcases a candidate's capability to solve complex problems efficiently. Employers seek individuals who can address real-world challenges effectively.\n\nFoundation for software development: Algorithms and data structures form the bedrock of software development. Competence in these areas signifies a strong grasp of fundamental concepts crucial for writing code that is both efficient and maintainable.\n\nScalability and performance: Understanding algorithms and data structures is essential for developing software that is scalable and performs well under various conditions. Employers aim to ensure that their systems can handle large volumes of data while maintaining efficiency.\n\nStandardized evaluation: Algorithm and data structure questions offer a standardized method for evaluating candidates, enabling interviewers to assess technical abilities more objectively and make informed comparisons among applicants.\n\nIn summary, proficiency in algorithms and data structures is highly esteemed because it underscores a candidate's problem-solving aptitude, foundational knowledge, and potential to contribute meaningfully to software development teams.",
      "tags": ["interviews", "dsa", "programming", "problem solving"]
    },
    {
      "title": "What's the quickest and most effective method for mastering data structures and algorithms?",
      "author": "coderat5",
      "content": "The most efficient way to grasp data structures and algorithms involves a dual approach of studying theory and actively coding. Various resources like online courses, textbooks, and coding challenges aid in comprehending concepts and applying them practically.\n\nRegarding the simplest language for learning data structures and algorithms, it depends on personal preference and available resources. Python, Java, and C++ are popular choices. Python is often recommended for beginners due to its clear syntax, enabling focused learning on concepts. However, Java and C++ are also widely used in the industry and offer robust support for these topics.\n\nUltimately, the ideal language for learning data structures and algorithms is the one that feels most comfortable and provides ample resources for learning and practicing.",
      "tags": ["learning", "dsa"]
    },
    {
      "title": "Exploring the World of Competitive Programming: A Journey of Skill, Strategy, and Community",
      "author": "hynaLuam",
      "content": "Competitive programming has emerged as a popular sport among computer programmers worldwide, blending the thrill of competition with the intricacies of algorithmic problem-solving. In this fast-paced discipline, participants tackle a series of programming challenges within a specified time frame, aiming to devise efficient solutions and outperform their peers.\n\nOne of the defining features of competitive programming is its emphasis on algorithms and data structures. Participants must possess a solid understanding of these fundamental concepts to devise optimal solutions within the constraints of time and memory. Through regular practice and participation in online coding competitions, programmers hone their skills in problem analysis, algorithm design, and implementation.\n\nCompetitive programming platforms such as Codeforces, Topcoder, and LeetCode host a plethora of contests and practice problems spanning various difficulty levels and topics. These platforms provide a fertile ground for aspiring programmers to sharpen their skills, learn new techniques, and measure their progress against a global community of enthusiasts.\n\nBeyond its competitive aspect, competitive programming fosters collaboration and camaraderie among participants. Online forums and communities offer opportunities for knowledge sharing, code reviews, and mutual support, enriching the learning experience and fostering a sense of belonging within the programming community.\n\nIn summary, competitive programming offers a stimulating environment for programmers to enhance their problem-solving abilities, deepen their understanding of algorithms and data structures, and connect with like-minded individuals passionate about coding.",
      "tags": ["competitive programming", "engineering", "skill development"]
    },
    {
      "title": "Some tips to consider while problem-solving",
      "author": "mehedi17n",
      "content": "Some tips to consider while problem-solving:\n\n - If an input array is sorted then Binary search Two pointers\n\n - If asked for all permutations/subsets then Backtracking\n\n - If given a tree then DFS BFS\n\n - If given a graph then DFS BFS\n\n - If given a linked list then Two pointers\n\n - If recursion is banned then Stack\n\n - If must solve in-place then Swap corresponding values Store one or more different values in the same pointer\n\n - If asked for maximum/minimum subarray/subset/options then Dynamic programming\n\n - If asked for top/least K items then Heap\n\n - If asked for common strings then Map Trie\n\nElse Map/Set for O(1) time & O(n) space Sort input for O(nlogn) time and O(1) space",
      "tags": ["problem solving", "cp"]
    },
    {
      "title": "How to solve/approach a DP problem?",
      "author": "SPyofgame",
      "content": "For simple dynamic programming problem, you can just make a correct recursive bruteforce (just dont mind the time limit). Then put all variables that is not considered as constant into function parameters (for which is calculated this time but changed after transiting)\n\nYou have base cases (to stop recursive)\n\nYou have transitions (relationship about those parameters)\n\nYou have the value from those smaller recursive problem\n\nYou just not have the memorization\n\nTherefore, for such parameters that you care in transition, use them as memorization, and then you have a DP solution\n\nSo, for practice simple dp problem, you can simply do brute force recursive and then add memorization\n\nBut, for harder ones, you have to optimize it in somehow\n\nChange into iterative dp (in order to apply some other kind of transitions or calculating that recursive cant)\n\nChanging the transitions (usually math)\n\nOptimizing the calculating (usually math or data structure)\n\nOptimizing the memorization (usually data structure)...\n\nConvert to other kind of problem that solvable with better algorithm",
      "tags": ["dynamic programming"]
    },
    {
      "title": "Optimizing Time and Space Complexity: Tips and Tricks for Competitive Programming Success",
      "author": "cfuser01",
      "content": "In the fast-paced world of competitive programming, optimizing time and space complexity is a crucial skill that separates the amateurs from the champions. In these high-stakes contests where every millisecond counts, efficient algorithms can make the difference between victory and defeat. Here are some tips and tricks to help aspiring competitive programmers achieve success through optimization.\n\nFirstly, understanding the importance of time and space complexity is paramount. Time complexity refers to the amount of time an algorithm takes to complete as a function of the size of its input, while space complexity measures the amount of memory required by the algorithm. Both factors are critical in competitive programming, where efficiency is key.\n\nOne effective strategy for optimizing time complexity is to choose the right algorithm for the task at hand. Familiarity with common algorithms and data structures such as sorting algorithms, search algorithms, and dynamic programming techniques can help programmers select the most efficient solution for a given problem.\n\nAdditionally, programmers can employ various optimization techniques to improve the efficiency of their code. This includes memoization, which stores previously computed results to avoid redundant calculations, and pruning, which eliminates unnecessary branches in search algorithms.\n\nFurthermore, being mindful of space complexity is equally important. Minimizing memory usage can prevent runtime errors and improve the overall performance of the program. Techniques such as using smaller data types, reusing memory, and avoiding unnecessary data structures can help reduce space complexity.\n\nIn conclusion, mastering the art of optimizing time and space complexity is essential for competitive programming success. By understanding the fundamentals, choosing efficient algorithms, and employing optimization techniques, programmers can improve their chances of achieving victory in competitive programming contests.",
      "tags": ["cp", "time complexity", "space complexity"]
    }
  ]
}
